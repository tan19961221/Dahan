4.创建线程的两种方式分别是什么？各有什么优缺点？
a.Thread类：优点：编写简单；缺点：无法继承其它父类，不能实现资源共享。
b.Runnable接口：优点：可继承其它类，多线程可共享同一个Thread对象；缺点：编写稍复杂，要访问当前线程需调用Thread.courrentThread()方法。

5.请你简述sleep( )和wait( )有什么区别？
sleep()：属于Thread类，sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

wait()：属于Object类，而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

6.Java中实现线程通信的三个方法及其作用？
1、传统的线程通信。
在synchronized修饰的同步方法或者修饰的同步代码块中使用Object类提供的wait(),notify()和notifyAll()3个方法进行线程通信
wait():导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。
notify():唤醒在此同步监视器上等待的单个线程。
notifyAll():唤醒在此同步监视器上等待的所有线程。

2、使用Condition控制线程通信。
当程序使用Lock对象来保证同步，系统不存在隐式的同步监视器，只能用Condition类来控制线程通信。
await():类似于隐式同步监视器上的wait()方法，导致当前线程等待，直到其他线程调用该Condition的signal()方法或signalAll()方法来唤醒该线程。
signal():唤醒在此Lock对象上等待的单个线程。如果所有的线程都在该Lock对象上等待，则会选择唤醒其中一个线程。选择是任意性的。
signalAll():唤醒在此Lock对象上等待的所有线程，只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的线程。

3、使用阻塞队列（BlockingQueue）控制线程通信（也实现了生产者消费者模式）
put(E e):尝试把E元素放入BlockingQueue中，如果该队列的元素已满，则阻塞该线程。
take():尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。
7.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？
Thread 类的 join 方法实现

8.Java中新的Lock接口相对于同步代码块（synchronizedblock）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性。
优势：它为读和写提供两个单独的锁。

9.Java 中 wait 和 sleep 方法有什么区别？
同上5

10.如何在 Java 中编写代码解决生产者消费者问题
Lock接口在多线程和并发编程中最大的优势是它们分别为读和写提供了锁。
    使用读写锁ReentrantReadWriteLock，
    它表示有两个锁，一个是读操作相关的锁，也称为共享锁；
    另一个是写操作相关的锁，也叫排他锁。“读写”、“写读”、和 “写写“ 都是互斥的；而 ”读读“ 是异步的，非互斥的
    即：多个线程可以同时进行读取操作，但是同一时刻只允许一个线程进行写入操作。

11.写一段死锁代码。你在 Java 中如何解决死锁？
死锁发生需要必备的四个条件：
1-互斥条件，资源中必须有一个不能被共享；
2-至少有一个任务它必须持有一个资源且正在等待获取另外一个当前被别的任务持有的资源；
3-资源不能被任务抢占；
4-必须有循环等待。

解决办法，即破坏四个条件就可
1-加锁顺序，所有的线程都按照顺序获取锁。破坏掉第二条。
2-加锁时限，在获取锁的时候加一个超时时间，如果超时，则释放已占用的锁。破坏掉第四条。
3-死锁检测。破坏掉第二条。

12.什么是原子操作？Java 中有哪些原子操作
所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，

13.既然 start() 方法会调用 run() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法
调用 start() 方法时，它会新建一个线程然后执行 run() 方法中的代码。如果直接调用 run() 方法，并不会创建新线程，方法中的代码会在当前调用者的线程中执行







